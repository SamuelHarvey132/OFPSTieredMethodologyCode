# --- Import Libraries ---
import os
import geopandas as gpd
import xarray as xr
import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import pandas as pd
from shapely.geometry import Point

# --- Configuration ---
PORT_BUFFER_METERS = 20000  # 20 km buffer around ports

# --- Set up Relative File Paths and Create Output Directory ---
# This script assumes a standard project structure.
data_dir = '../data'
results_dir = '../results'

# Create the results directory if it doesn't exist
if not os.path.exists(results_dir):
    os.makedirs(results_dir)

# --- Define All Input and Output File Paths ---
# Tier 1 Data Paths
coastline_path = os.path.join(data_dir, 'ne_10m_coastline/ne_10m_coastline.shp')
ocean_path = os.path.join(data_dir, 'ne_10m_ocean/ne_10m_ocean.shp')
bathymetry_path = os.path.join(data_dir, 'Depth.nc')
maximum_individual_wave_path = os.path.join(data_dir, 'MaximumIndividualWave.nc')
instantaneous_wind_path = os.path.join(data_dir, 'InstantaneousWind.nc')
era5_data_path = os.path.join(data_dir, 'Australia.nc')

# Tier 2 Shapefile Paths
mpa_path = os.path.join(data_dir, 'Marine_Protected_Areas/CAPAD2020_marine.shp')
ports_path = os.path.join(data_dir, 'Major_Maritime_Ports/Maritime_Ports.shp')

# Output Paths
output_map_path = os.path.join(results_dir, 'Final_Viability_Map.png')
output_csv_path = os.path.join(results_dir, 'Final_Viable_Coordinates.csv')

# --- Filtering Parameters (Tier 1) ---
max_distance_km = 100
max_water_depth_m = 60
max_hmax_m = 5
max_wind_speed_ms = 30

# --- 1. Load Geographical and Metocean Data (Tier 1) ---
print("\n--- Loading Tier 1 Data ---")
coastline_gdf = gpd.read_file(coastline_path)
global_coastline = coastline_gdf.geometry.union_all()
ocean_gdf = gpd.read_file(ocean_path)
global_ocean = ocean_gdf.geometry.union_all()
bathymetry_ds = xr.open_dataset(bathymetry_path)
hmax_ds = xr.open_dataset(maximum_individual_wave_path)
wind_ds = xr.open_dataset(instantaneous_wind_path)
era5_ds = xr.open_dataset(era5_data_path)
print("Tier 1 data loaded.")

# --- Process Metocean Data ---
def process_metocean_array(data_array):
    """Safely processes a metocean data array by renaming dimensions and finding the max over time."""
    rename_dict = {}
    if 'lon' in data_array.dims: rename_dict['lon'] = 'longitude'
    if 'lat' in data_array.dims: rename_dict['lat'] = 'latitude'
    if rename_dict: data_array = data_array.rename(rename_dict)

    time_dim_name = next((dim for dim in ['time', 'valid_time', 't'] if dim in data_array.dims), None)

    if time_dim_name:
        return data_array.max(dim=time_dim_name, skipna=True)
    else:
        return data_array.squeeze(drop=True)

bathymetry_data = process_metocean_array(bathymetry_ds['wmb'])
max_hmax_data = process_metocean_array(hmax_ds[list(hmax_ds.data_vars)[0]])
max_wind_speed_data = process_metocean_array(wind_ds[list(wind_ds.data_vars)[0]])
print("Metocean data processed safely.")


# --- 2. Prepare ERA5 Grid and Perform Tier 1 Filtering ---
print("\n--- Performing Tier 1 Filtering ---")
lons, lats = era5_ds['longitude'].values, era5_ds['latitude'].values
lon_grid, lat_grid = np.meshgrid(lons, lats)
all_era5_points_gdf = gpd.GeoDataFrame(geometry=[Point(lon, lat) for lon, lat in zip(lon_grid.flatten(), lat_grid.flatten())], crs="EPSG:4326")

projected_all_era5_points = all_era5_points_gdf.to_crs("EPSG:32663")
projected_coastline = gpd.GeoDataFrame(geometry=[global_coastline], crs="EPSG:4326").to_crs("EPSG:32663")
projected_ocean = gpd.GeoDataFrame(geometry=[global_ocean], crs="EPSG:4326").to_crs("EPSG:32663")

all_era5_points_gdf['distance_to_shore_km'] = projected_all_era5_points.distance(projected_coastline.iloc[0].geometry) / 1000
ocean_indices = gpd.sjoin(projected_all_era5_points, projected_ocean, how="inner", predicate="intersects").index

relevant_indices = all_era5_points_gdf[(all_era5_points_gdf['distance_to_shore_km'] <= max_distance_km) & (all_era5_points_gdf.index.isin(ocean_indices))].index
interp_lons = xr.DataArray(all_era5_points_gdf.loc[relevant_indices].geometry.x, dims="points", coords={'points': relevant_indices})
interp_lats = xr.DataArray(all_era5_points_gdf.loc[relevant_indices].geometry.y, dims="points", coords={'points': relevant_indices})

depth_values = bathymetry_data.interp(longitude=interp_lons, latitude=interp_lats, method='nearest')
hmax_values = max_hmax_data.interp(longitude=interp_lons, latitude=interp_lats, method='nearest')
wind_values = max_wind_speed_data.interp(longitude=interp_lons, latitude=interp_lats, method='nearest')

all_era5_points_gdf['cond_dist_100km'] = (all_era5_points_gdf['distance_to_shore_km'] <= max_distance_km)
all_era5_points_gdf['cond_ocean'] = all_era5_points_gdf.index.isin(ocean_indices)
all_era5_points_gdf.loc[relevant_indices, 'cond_depth_60m'] = (depth_values.values <= max_water_depth_m)
all_era5_points_gdf.loc[relevant_indices, 'cond_hmax_5m'] = (hmax_values.values <= max_hmax_m)
all_era5_points_gdf.loc[relevant_indices, 'cond_wind_30ms'] = (wind_values.values <= max_wind_speed_ms)
all_era5_points_gdf.fillna(False, inplace=True)

tier1_optimal_mask = (all_era5_points_gdf['cond_dist_100km'] & all_era5_points_gdf['cond_ocean'] & all_era5_points_gdf['cond_depth_60m'] & all_era5_points_gdf['cond_hmax_5m'] & all_era5_points_gdf['cond_wind_30ms'])
tier1_optimal_gdf = all_era5_points_gdf[tier1_optimal_mask].copy() # Use .copy() to avoid SettingWithCopyWarning
print(f"Identified {len(tier1_optimal_gdf)} optimal points from Tier 1.")

# --- 3. Perform Tier 2 Filtering on Tier 1 Optimal Sites ---
print("\n--- Performing Tier 2 Filtering ---")
mpa_gdf = gpd.read_file(mpa_path).to_crs(all_era5_points_gdf.crs)
ports_gdf = gpd.read_file(ports_path).to_crs(all_era5_points_gdf.crs)

points_in_mpa = gpd.sjoin(tier1_optimal_gdf, mpa_gdf, how='inner', predicate='intersects')
mpa_removed_indices = points_in_mpa.index.unique()
print(f"Identified {len(mpa_removed_indices)} points within Marine Protected Areas.")

remaining_after_mpa = tier1_optimal_gdf.drop(mpa_removed_indices, errors='ignore')
projected_crs = "EPSG:3857"
remaining_proj = remaining_after_mpa.to_crs(projected_crs)
ports_proj = ports_gdf.to_crs(projected_crs)
ports_buffer_union = ports_proj.buffer(PORT_BUFFER_METERS).unary_union
port_removed_mask = remaining_proj.intersects(ports_buffer_union)
port_removed_indices = remaining_proj[port_removed_mask].index
print(f"Identified {len(port_removed_indices)} points within {PORT_BUFFER_METERS / 1000}km of a Major Port.")

# --- 4. Assign Final Categories for Plotting ---
print("\n--- Assigning Final Categories for Visualization ---")
all_era5_points_gdf['category_name'] = 'Tier 1: Physical Limit Fail'
all_era5_points_gdf.loc[tier1_optimal_mask, 'category_name'] = 'Final Viable Site'
all_era5_points_gdf.loc[mpa_removed_indices, 'category_name'] = 'Removed: In Marine Protected Area'
all_era5_points_gdf.loc[port_removed_indices, 'category_name'] = 'Removed: Too Close to Port'

final_viable_sites_gdf = all_era5_points_gdf[all_era5_points_gdf['category_name'] == 'Final Viable Site']
print(f"Final count of viable sites: {len(final_viable_sites_gdf)}")

# --- 5. Visualize the Final Filtered Sites ---
print("\n--- Generating Final Map ---")
plt.figure(figsize=(16, 14))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([110, 155, -45, -10], crs=ccrs.PlateCarree())
ax.add_feature(cfeature.LAND, edgecolor='black', facecolor='lightgray', zorder=0)
ax.add_feature(cfeature.OCEAN, facecolor='lightblue', zorder=0)
ax.add_feature(cfeature.BORDERS, linestyle=':', edgecolor='gray')
coastline_gdf.plot(ax=ax, color='black', linewidth=0.8)

plot_colors = {
    'Removed: In Marine Protected Area': 'orange',
    'Removed: Too Close to Port': 'red',
    'Final Viable Site': 'green'
}
plot_order = ['Removed: In Marine Protected Area', 'Removed: Too Close to Port', 'Final Viable Site']

for category_name in plot_order:
    subset = all_era5_points_gdf[all_era5_points_gdf['category_name'] == category_name]
    if not subset.empty:
        subset.plot(
            ax=ax,
            marker='o',
            color=plot_colors.get(category_name, 'black'),
            markersize=15,
            alpha=0.8,
            label=f'{category_name} ({len(subset)})',
            zorder=3
        )

gl = ax.gridlines(draw_labels=True, linestyle='--', color='gray', alpha=0.6)
gl.top_labels = False
gl.right_labels = False

plt.title('Final Viability Map Including Tier 1 & Tier 2 Filters', fontsize=20)
plt.legend(loc='lower left', fontsize=20, frameon=True, facecolor='white', framealpha=0.8)

plt.savefig(output_map_path, bbox_inches='tight')
print(f"Plot saved to {output_map_path}")
plt.show()

# --- 6. Save Final Viable Coordinates ---
if not final_viable_sites_gdf.empty:
    final_output_df = pd.DataFrame({
        'latitude': final_viable_sites_gdf.geometry.y,
        'longitude': final_viable_sites_gdf.geometry.x
    })
    final_output_df.to_csv(output_csv_path, index=False)
    print(f"\n✅ {len(final_output_df)} final viable coordinates saved to: {output_csv_path}")
else:
    print("\n⚠️ No points remained after all filtering stages.")
